use std::str::FromStr;
use std::collections::BTreeMap;
use ast::*; // (0)

grammar;

pub QueryContext: Box<Context> = {
    <ql:QueryList> <q:Query> => Box::new(Context{ queries: ql, main_query: q })
};

QueryList: BTreeMap<String, Box<Query>> = {
     => BTreeMap::new(),
    <qs: QueryList> "let" <id:Ident> "=" <last: Query> ";" => {
        let mut qs = qs;
        qs.insert(id, last);
        qs
    }
};

Query: Box<Query> = {
    <fc:FromClause?> <wc:WhereClause?> <sc:SelectClause> => 
        Box::new(Query::Simple {
            var_decls: fc.unwrap_or(vec![]), // match fc { Some(fc) => fc, None => vec![] },
            conditions: wc, // match wc { Some(wc) => wc, None => vec![] },
            selections: sc,
        }), 
    "(" <q1:Query> ")" "union" "(" <q2:Query> ")" => Box::new(Query::Union(q1, q2))
};

WhereClause: Box<Expr> = {
    "where" <e:Expr> => e
};

FromClause: Vec<VarDecl> = {
    "from" <vs:VarDecls> => vs
};

SelectClause: Vec<Box<Expr>> = {
    "select" <es:Exprs> => es
};

CommaList<Rule>: Vec<Rule> = {
    <args: (<Rule> ",")*> <last: Rule?> => {
        let mut args = args;
        args.extend(last);
        args
    }
};

Exprs: Vec<Box<Expr>> = {
    <elems: CommaList<Expr>> => elems
};

//Exprs: Vec<Box<Expr>> = {
//     Expr => vec![<>; 1],
//     <es:Exprs> "," <e:Expr> => { es.push(e); es }
//}

VarDecls: Vec<VarDecl> = {
    <decls: CommaList<VarDecl>> => decls
//    VarDecl => vec![<>; 1],
//    <vs:VarDecls> "," <v:VarDecl> => { let mut vsn = vs.clone(); vsn.push(v); vsn }
};

VarDecl: VarDecl = {
    <n:Ident> ":" <tn:Ident> => VarDecl{name: n, type_name: tn}
};

Expr: Box<Expr> = { // (1)
    Expr ExprOp Factor => Box::new(Expr::Op(<>)), // (2)
    Factor,
};

ExprOp: Op = { // (3)
    "+" => Op::Add,
    "-" => Op::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp Term => Box::new(Expr::Op(<>)),
    Term,
};

FactorOp: Op = {
    "*" => Op::Mul,
    "/" => Op::Div,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)), // (4)
    MethodCall => <>,
    Ident => Box::new(Expr::Ident(<>)),
    Str => Box::new(Expr::Str(<>)),
    "(" <ex:Expr> ")" => ex
};

MethodCall: Box<Expr> = {
    <t:Term> "." <n:Ident> "(" <a: CommaList<Expr>> ")" =>
        Box::new(Expr::MethodCall{ target: t, name: n, args: a })
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Ident: String = {
    r"[A-Za-z_][A-Za-z0-9_]*" => String::from(<>)
};

Str: String = {
    r#""[^"]*""# => String::from(<>.trim_matches('"'))
}

